# Bytecode
В этой части документации рассказывается о том, как писать байт код для виртуальной машины Moon

>[!IMPORTANT]
> Важно отметить, что каждый элемент в байт-коде пишется через запятую!(в переменной program(src/main.cpp)). На примерах байт-кода **нету** запятых, например:
> ```bytecode
> PUSH 10
> PRINT
>```
> Если так напишите в program, то будет ошибка, правильно так:
> ```bytecode
>PUSH, 10,
> PRINT //На последней команде запятую можно не ставить 
>``` 
> Также в документации упомянуты строки в байт-коде, их в C++ нужно писать так: std::string("тут строка, например имя метки")

>[!IMPORTANT]
> Документация не успевает за комитами, поэтому какие то части байт кода **могут не работать**


## Базовые опкоды виртуальной машины которые чаще всего используются
В виртуальной машине есть такие опкоды, которые достаточно редко используются, но для них будет отдельная документация.

- **PUSH** - помещает элемент на вершину стека
```bytecode
PUSH 10
```
- **POP** - удаляет элемент с вершины стека
```bytecode
PUSH 10
PUSH 20
PRINT // Выведет и заберёт верхнее значение из стека
POP // Удаляем то что осталось
PRINT // Выдаст ошибку так как стек станет пустым
```
- **ADD** - складывает первые 2 верних элемента в стеке, помещая результат на вершину стека
```bytecode
PUSH 2
PUSH 2
ADD
PRINT // Результат: 4
```
- **SUB** - вычитает первые 2 верних элемента в стеке, помещая результат на вершину стека
```bytecode
PUSH 4
PUSH 2
SUB
PRINT // Результат: 2
```
- **MUL** - умножает первые 2 верних элемента в стеке, помещая результат на вершину стека
```bytecode
PUSH 2
PUSH 6
MUL
PRINT // Результат: 12
```
- **DIV** - делит первые 2 верних элемента в стеке, помещая результат на вершину стека
```bytecode
PUSH 12
PUSH 2
DIV
PRINT // Результат: 6
```
- **MOD** - деление с возвратом остатка
```bytecode
PUSH 12
PUSH 5
MOD
PRINT // Результат: 4 
```
- **INC** - инкремент
```bytecode
PUSH 0
INC
PRINT // Результат: 1
```
- **DEC** - декремент
```bytecode
PUSH 0
DEC
PRINT // Результат: -1
```
- **NEG** - получить отрицательное число
```bytecode
PUSH -1
NEG
PRINT // Результат: 1
```
- **ABS** - абсолютное число
```bytecode
PUSH -2 
ABS
PRINT // Результат: 2
```
- **POW** - возведение в степень
```bytecode
PUSH 6 //основа
PUSH 2 //степень
POW
PRINT // Результат: 36
```
- **SQRT** - квадратный корень
```bytecode
PUSH 36
SQRT
PRINT // Результат: 6
```
- **PRINT** - выводит элемент из вершины стека, забирая его
- **HALT** - завершает работу программы 
- **STORE_GLOBAL** - помещает верхний элемент из стека в глобальную переменную
```bytecode
PUSH 10 
STORE_GLOBAL 0 //Помещает элемент 10 в переменную 0
```
- **LOAD_GLOBAL** - загружает глобальную переменную, и значение переменной помещает на вершину стека
```bytecode
LOAD_GLOBAL 0
PRINT //Если до этого момента где-то была создана переменная 0 то выведется значение переменной
```
- **JUMP** - совершает прыжок по областям байт-кода

	**Что такое область байт-кода?**
	Это порядковое значение  какой то части байт-кода, виртуальная машина сама создаёт карту областей, где хранится порядковый номер области и с какого индекса в байт коде начинается та или иная область, наглядно:
```bytecode
PUSH, 10, PUSH, 20, ADD, PRINT, HALT
```
Так как весь байт код хранится в векторе, каждый элемент имеет индекс начиная с нуля:
```bytecode
PUSH, 10, PUSH, 20, ADD, PRINT, HALT
0     1   2     3   4    5      6
```
И виртуальная машина проходится по этому всему вектору, создавая карту областей, учитывая, принимает ли тот или иной опкод аргумент или нет, и по специальному алгоритму создаются области, где лежит информация где эта область начинается:
```bytecode
PUSH, 10, PUSH, 20, ADD, PRINT, HALT
1         2         3    4      5
```
Номер области это просто ключ в карте, и значение этого ключа это индекс откуда стартует область, и любая область имеет конец и этим концом является последняя команда байт-кода.
```bytecode
PUSH, 10, PUSH, 20, ADD, PRINT, HALT
1         2         3    4      5
0         2         4    5      6
```
Первая строка чисел это порядковый номер области, а нижняя строка чисел это стартовый индекс для порядкового номера области, теперь перейдём к самому JUMP
```bytecode
PUSH 10
PUSH 20
ADD
PRINT
JUMP 1
HALT
```
В данном примере кода показан по сути вечный цикл без условия, который вечно выводит сумму 10 и 20, и у JUMP мы указываем на какую область мы должны перейти и где продолжить код, нагляднее:
```bytecode
PUSH 10   [1]
PUSH 20   [2]
ADD       [3]
PRINT     [4]
JUMP 1    [5]
HALT      [7]
```
В квадратных скобках для каждой команды указана область, если смотреть под таким углом на код, то это напоминает обычные строки в коде, и поэтому можно сильно с областями не парится а просто каждую новую команду писать с новой строки и запомнить это как обычный переход к строки, и вот вывод нашей программы:
```
30
30
30
30
30
30
... // И так далее
```
- **LABEL** - метка в байт-коде

	Это по сути инструмент для упрощения работы над прыжками, так как тут не нужно заботится о том правильно ли указана область кода для прыжка туда куда нам надо, мы можем просто создать такого рода метки:
```bytecode
LABEL "loop"
	PUSH 10
	PUSH 20
	PRINT
	JUMP "loop"
LABEL "start"
	JUMP "loop" //ПРОГРАММА СТАРТАНЁТ ОТСЮДА
```
Тот кто работал с ассемблером уже наверняка поняли что делает данный код, метка это указатель где должен начаться выполнятся код, виртуальная машина прежде чем выполнить написанный байт-код, он обрабатывает байт код в 2 этапа, который включает в себя анализ меток и замена строковых значений на области, на выходе этого анализа простой байт-код где JUMP уже имеет стандартное числовое значение в аргументе.

	>Важно отметить то, что если вы используете метки, то **ОБЯЗАТЕЛЬНО** указывайте метку "start", чтобы код стартовал именно с той части программы откуда вам надо, в противном случае машина просто построчно выполнит ваш байт-код включая метки, что может вызвать не те результаты, которые вам бы хотелось видеть.

- **DUP** - дублирует верхний элемент в стеке
```bytecode
PUSH 10 //значения в стеке: 10
PRINT //значения в стеке после этой программы: нету
PRINT //Вызовет ошибку, ведь стек пустой
```

```bytecode
PUSH 10 //значения в стеке: 10
DUP //значения в стеке: 10, 10
PRINT //значения в стеке после этой программы: 10
PRINT //Выведет 10, как и прошлый print, потому что теперь у нас не одна десятка в стеке, а две
```
- **SWAP** - меняет местами два верних элемента в стеке
Код без SWAP:
```bytecode
PUSH 10
PUSH 90
PRINT
PRINT
```
Результат:
```
90
10
```
Код вместе со SWAP:
```bytecode
PUSH 10
PUSH 90
SWAP
PRINT
PRINT
```
Результат:
```
10
90
```
### Логические опкоды
#### Условные прыжки
Это тоже по сути прыжки, только они прыгают по заданному условию, например если два верхних элемента в стеке равны то прыгнуть в вечный цикл(к примеру). Любой условный прыжок также как и обычный может прыгать по областям байт-кода, или по заданным меткам

- **CMP_EQ** - сравнивает два верхних значения в стеке знаком ==
```bytecode
LABEL "yes"
	PUSH 1
	PRINT
	JUMP ".end" //Прыгаем в конец чтобы завершить программу
LABEL "start"
	PUSH 90 // a
	PUSH 90 // b
	CMP_EQ "yes" // Если a == b то прыгаем в метку yes 
LABEL ".end"
	HALT
```
- **CMP_NE** - сравнивает два верхних значения в стеке знаком !=
```bytecode
LABEL "yes"
	PUSH 1
	PRINT
	JUMP ".end" //Прыгаем в конец чтобы завершить программу
LABEL "start"
	PUSH 38 // a
	PUSH 90 // b
	CMP_NE "yes" // Если a != b то прыгаем в метку yes 
LABEL ".end"
	HALT
```
- **CMP_GT** - сравнивает два верхних значения в стеке знаком >
```bytecode
LABEL "yes"
	PUSH 1
	PRINT
	JUMP ".end" //Прыгаем в конец чтобы завершить программу
LABEL "start"
	PUSH 38 // a
	PUSH 90 // b
	CMP_GT "yes" // Если a > b то прыгаем в метку yes 
LABEL ".end"
	HALT
```
- **CMP_LT** - сравнивает два верхних значения в стеке знаком <
```bytecode
LABEL "yes"
	PUSH 1
	PRINT
	JUMP ".end" //Прыгаем в конец чтобы завершить программу
LABEL "start"
	PUSH 90 // a
	PUSH 38 // b
	CMP_LT "yes" // Если a < b то прыгаем в метку yes 
LABEL ".end"
	HALT
```
#### Логические операции
- **AND** - логическое 'и'
```bytecode
PUSH 1 //a
PUSH 1 //b
AND // Если два верхних элемента истина, то наверх стека помещаем истину(1), иначе ложь(0)
```
- **OR** - логическое 'или'
```bytecode
PUSH 1 //a
PUSH 0 //b
OR // Если из двух верхних элементов хоть одна истина, то наверх стека помещаем истину(1), иначе ложь(0)
```
- **NOT** - логическое 'не'
```bytecode
PUSH 1 //a
NOT // Если верхний элемент 1 то на стек помещаем 0, если 0 то 1
```
